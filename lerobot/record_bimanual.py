# Copyright 2024 The HuggingFace Inc. team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
Records a dataset using bimanual robot setup. Actions for the robot can be either generated by teleoperation or by a policy.

Continuous Recording Mode:
When continuous_recording=True, episodes will record indefinitely until manually terminated
using keyboard controls:
- Right Arrow (→): Finish current episode and start next one
- Left Arrow (←): Cancel current episode and re-record it  
- Down Arrow (↓): Continue recording current episode (if accidentally stopped)
- Escape (ESC): Stop recording session completely

Standard Timed Recording Mode:
When continuous_recording=False (default), episodes record for a fixed duration.

Example for continuous recording:

```shell
python -m lerobot.record_bimanual \
    --robot.type=bimanual_follower \
    --robot.left_port=/dev/ttyUSB0 \
    --robot.right_port=/dev/ttyUSB1 \
    --robot.cameras="{laptop: {type: opencv, camera_index: 0, width: 640, height: 480}}" \
    --teleop.type=bimanual_leader \
    --teleop.left_port=/dev/ttyUSB2 \
    --teleop.right_port=/dev/ttyUSB3 \
    --dataset.repo_id=user/bimanual-dataset \
    --dataset.continuous_recording=true \
    --dataset.num_episodes=10 \
    --dataset.single_task="Pick and place objects"
```

Example for timed recording (classic mode):

```shell
python -m lerobot.record_bimanual \
    --robot.type=bimanual_follower \
    --robot.left_port=/dev/ttyUSB0 \
    --robot.right_port=/dev/ttyUSB1 \
    --robot.cameras="{laptop: {type: opencv, camera_index: 0, width: 640, height: 480}}" \
    --teleop.type=bimanual_leader \
    --teleop.left_port=/dev/ttyUSB2 \
    --teleop.right_port=/dev/ttyUSB3 \
    --dataset.repo_id=user/bimanual-dataset \
    --dataset.continuous_recording=false \
    --dataset.episode_time_s=60 \
    --dataset.reset_time_s=30 \
    --dataset.num_episodes=10 \
    --dataset.single_task="Pick and place objects"
```
"""

import logging
import time
from dataclasses import asdict, dataclass
from pathlib import Path
from pprint import pformat

import numpy as np
import rerun as rr
from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.text import Text
from rich.align import Align

from lerobot.common.cameras import (  # noqa: F401
    CameraConfig,  # noqa: F401
)
from lerobot.common.cameras.opencv.configuration_opencv import OpenCVCameraConfig  # noqa: F401
from lerobot.common.cameras.realsense.configuration_realsense import RealSenseCameraConfig  # noqa: F401
from lerobot.common.datasets.image_writer import safe_stop_image_writer
from lerobot.common.datasets.lerobot_dataset import LeRobotDataset
from lerobot.common.datasets.utils import build_dataset_frame, hw_to_dataset_features
from lerobot.common.policies.factory import make_policy
from lerobot.common.policies.pretrained import PreTrainedPolicy
from lerobot.common.robots import (  # noqa: F401
    Robot,
    RobotConfig,
    koch_follower,
    make_robot_from_config,
    so100_follower,
    so101_follower,
    bimanual_follower,
)
from lerobot.common.teleoperators import (  # noqa: F401
    Teleoperator,
    TeleoperatorConfig,
    make_teleoperator_from_config,
)
from lerobot.common.utils.control_utils import (
    init_keyboard_listener,
    is_headless,
    predict_action,
    sanity_check_dataset_name,
    sanity_check_dataset_robot_compatibility,
)
from lerobot.common.utils.robot_utils import busy_wait
from lerobot.common.utils.utils import (
    get_safe_torch_device,
    init_logging,
    log_say,
)
from lerobot.common.utils.visualization_utils import _init_rerun
from lerobot.configs import parser
from lerobot.configs.policies import PreTrainedConfig

from .common.teleoperators import koch_leader, so100_leader, so101_leader, bimanual_leader  # noqa: F401
from lerobot.xhuman.logger import logger

@dataclass
class DatasetRecordConfig:
    # Dataset identifier. By convention it should match '{hf_username}/{dataset_name}' (e.g. `lerobot/test`).
    repo_id: str
    # A short but accurate description of the task performed during the recording (e.g. "Pick the Lego block and drop it in the box on the right.")
    single_task: str
    # Root directory where the dataset will be stored (e.g. 'dataset/path').
    root: str | Path | None = None
    # Limit the frames per second.
    fps: int = 30
    # Enable continuous recording mode - episodes record until manually terminated
    continuous_recording: bool = False
    # Number of seconds for data recording for each episode (ignored if continuous_recording=True).
    episode_time_s: int | float = 60
    # Number of seconds for resetting the environment after each episode.
    reset_time_s: int | float = 60
    # Number of episodes to record (0 = unlimited).
    num_episodes: int = 0
    # Encode frames in the dataset into video
    video: bool = True
    # Upload dataset to Hugging Face hub.
    push_to_hub: bool = True
    # Upload on private repository on the Hugging Face hub.
    private: bool = False
    # Add tags to your dataset on the hub.
    tags: list[str] | None = None
    # Number of subprocesses handling the saving of frames as PNG. Set to 0 to use threads only;
    # set to ≥1 to use subprocesses, each using threads to write images. The best number of processes
    # and threads depends on your system. We recommend 4 threads per camera with 0 processes.
    # If fps is unstable, adjust the thread count. If still unstable, try using 1 or more subprocesses.
    num_image_writer_processes: int = 0
    # Number of threads writing the frames as png images on disk, per camera.
    # Too many threads might cause unstable teleoperation fps due to main thread being blocked.
    # Not enough threads might cause low camera fps.
    num_image_writer_threads_per_camera: int = 4

    def __post_init__(self):
        if self.single_task is None:
            raise ValueError("You need to provide a task as argument in `single_task`.")
        
        if self.continuous_recording:
            # In continuous mode, we set a very large episode time to avoid timeout
            self.episode_time_s = float('inf')


@dataclass
class RecordConfig:
    robot: RobotConfig
    dataset: DatasetRecordConfig
    # Whether to control the robot with a teleoperator
    teleop: TeleoperatorConfig | None = None
    # Whether to control the robot with a policy
    policy: PreTrainedConfig | None = None
    # Display all cameras on screen
    display_data: bool = False
    # Use vocal synthesis to read events.
    play_sounds: bool = True
    # Resume recording on an existing dataset.
    resume: bool = False

    def __post_init__(self):
        if bool(self.teleop) == bool(self.policy):
            raise ValueError("Choose either a policy or a teleoperator to control the robot")

        # HACK: We parse again the cli args here to get the pretrained path if there was one.
        policy_path = parser.get_path_arg("policy")
        if policy_path:
            cli_overrides = parser.get_cli_overrides("policy")
            self.policy = PreTrainedConfig.from_pretrained(policy_path, cli_overrides=cli_overrides)
            self.policy.pretrained_path = policy_path

    @classmethod
    def __get_path_fields__(cls) -> list[str]:
        """This enables the parser to load config from the policy using `--policy.path=local/dir`"""
        return ["policy"]


@safe_stop_image_writer
def record_loop(
    robot: Robot,
    events: dict,
    fps: int,
    dataset: LeRobotDataset | None = None,
    teleop: Teleoperator | None = None,
    policy: PreTrainedPolicy | None = None,
    control_time_s: int | None = None,
    single_task: str | None = None,
    display_data: bool = False,
):
    if dataset is not None and dataset.fps != fps:
        raise ValueError(f"The dataset fps should be equal to requested fps ({dataset.fps} != {fps}).")

    # if policy is given it needs cleaning up
    if policy is not None:
        policy.reset()

    timestamp = 0
    start_episode_t = time.perf_counter()
    # Handle both finite and infinite control time properly
    while (control_time_s == float('inf')) or (timestamp < control_time_s):
        start_loop_t = time.perf_counter()

        observation = robot.get_observation()

        if policy is not None or dataset is not None:
            observation_frame = build_dataset_frame(dataset.features, observation, prefix="observation")

        if policy is not None:
            action_values = predict_action(
                observation_frame,
                policy,
                get_safe_torch_device(policy.config.device),
                policy.config.use_amp,
                task=single_task,
                robot_type=robot.robot_type,
            )
            action = {key: action_values[i].item() for i, key in enumerate(robot.action_features)}
        else:
            action = teleop.get_action()

        # Action can eventually be clipped using `max_relative_target`,
        # so action actually sent is saved in the dataset.
        sent_action = robot.send_action(action)

        if dataset is not None:
            action_frame = build_dataset_frame(dataset.features, sent_action, prefix="action")
            frame = {**observation_frame, **action_frame}
            dataset.add_frame(frame, task=single_task)

        if display_data:
            for obs, val in observation.items():
                if isinstance(val, float):
                    rr.log(f"observation.{obs}", rr.Scalar(val))
                elif isinstance(val, np.ndarray):
                    rr.log(f"observation.{obs}", rr.Image(val), static=True)
            for act, val in action.items():
                if isinstance(val, float):
                    rr.log(f"action.{act}", rr.Scalar(val))

        dt_s = time.perf_counter() - start_loop_t
        busy_wait(1 / fps - dt_s)

        # Only update timestamp if not in infinite mode
        if control_time_s != float('inf'):
            timestamp = time.perf_counter() - start_episode_t
            
        if events["exit_early"]:
            events["exit_early"] = False
            break


def init_continuous_keyboard_listener():
    """
    Custom keyboard listener for continuous recording mode.
    
    Controls:
    - Right Arrow (→): Finish current episode and start next one
    - Left Arrow (←): Cancel current episode and re-record it  
    - Down Arrow (↓): Continue recording current episode (if accidentally stopped)
    - Escape (ESC): Stop recording session completely
    """
    events = {}
    events["exit_early"] = False
    events["rerecord_episode"] = False
    events["stop_recording"] = False
    events["finish_episode"] = False  # New event for continuous mode

    try:
        # Only import pynput if not in a headless environment
        from pynput import keyboard
    except ImportError:
        logging.warning(
            "pynput not available. Keyboard controls disabled for continuous recording."
        )
        return None, events

    def on_press(key):
        try:
            if key == keyboard.Key.right:
                print("→ Right arrow: Finishing current episode...")
                events["finish_episode"] = True
                events["exit_early"] = True
            elif key == keyboard.Key.left:
                print("← Left arrow: Canceling and re-recording episode...")
                events["rerecord_episode"] = True
                events["exit_early"] = True
            elif key == keyboard.Key.down:
                print("↓ Down arrow: Continue recording...")
                # Reset any exit flags to continue recording
                events["exit_early"] = False
                events["finish_episode"] = False
            elif key == keyboard.Key.esc:
                print("ESC: Stopping recording session...")
                events["stop_recording"] = True
                events["exit_early"] = True
        except Exception as e:
            print(f"Error handling key press: {e}")

    listener = keyboard.Listener(on_press=on_press)
    listener.start()

    return listener, events


def show_episode_menu(episode_count: int, task_name: str, repo_id: str):
    """
    Display a beautiful menu using rich after each episode
    """
    console = Console()
    
    # Clear screen
    console.clear()
    
    # Title
    title = Text("🤖 NONHUMAN BIMANUAL RECORDING 🤖", style="bold magenta")
    
    # Stats table
    stats_table = Table(show_header=True, header_style="bold cyan")
    stats_table.add_column("📊 STATISTIC", style="cyan", width=20)
    stats_table.add_column("📈 VALUE", style="yellow", width=30)
    
    stats_table.add_row("Episodes Recorded", f"[bold green]{episode_count}[/bold green]")
    stats_table.add_row("Task", f"[bold blue]{task_name}[/bold blue]")
    stats_table.add_row("Dataset", f"[bold white]{repo_id}[/bold white]")
    
    # Controls table
    controls_table = Table(show_header=True, header_style="bold green")
    controls_table.add_column("🎮 CONTROL", style="green", width=15)
    controls_table.add_column("📋 ACTION", style="white", width=35)
    
    controls_table.add_row("→ Right Arrow", "🎬 Start next episode")
    controls_table.add_row("← Left Arrow", "🔄 Re-record last episode") 
    controls_table.add_row("↓ Down Arrow", "▶️ Continue current episode")
    controls_table.add_row("ESC", "🛑 Stop recording & exit")
    
    # Status message
    status = Text("✅ Episode saved successfully! Choose your next action:", style="bold green")
    
    # Create panels
    title_panel = Panel(Align.center(title), style="bold magenta")
    stats_panel = Panel(stats_table, title="📊 Recording Statistics", style="cyan")
    controls_panel = Panel(controls_table, title="🎮 Available Controls", style="green")
    status_panel = Panel(Align.center(status), style="green")
    
    # Display everything
    console.print(title_panel)
    console.print("")
    console.print(stats_panel)
    console.print("")
    console.print(controls_panel)
    console.print("")
    console.print(status_panel)
    console.print("")
    console.print("[bold yellow]⏳ Waiting for your input...[/bold yellow]")


def show_final_summary(episode_count: int, task_name: str, repo_id: str):
    """
    Display a beautiful final summary when recording ends
    """
    console = Console()
    console.clear()
    
    # Final title
    title = Text("🏁 RECORDING SESSION COMPLETED 🏁", style="bold green")
    
    # Final stats table
    final_table = Table(show_header=True, header_style="bold green")
    final_table.add_column("📊 FINAL STATISTICS", style="green", width=25)
    final_table.add_column("📈 RESULT", style="yellow", width=30)
    
    final_table.add_row("Total Episodes Recorded", f"[bold green]{episode_count}[/bold green]")
    final_table.add_row("Task Completed", f"[bold blue]{task_name}[/bold blue]")
    final_table.add_row("Dataset Saved To", f"[bold white]{repo_id}[/bold white]")
    final_table.add_row("Status", "[bold green]✅ SUCCESS[/bold green]")
    
    # Create panels
    title_panel = Panel(Align.center(title), style="bold green")
    stats_panel = Panel(final_table, title="📊 Session Summary", style="green")
    
    # Thank you message
    thank_you = Text("🙏 Thank you for using LeRobot! Your data has been saved successfully.", style="bold cyan")
    thank_you_panel = Panel(Align.center(thank_you), style="cyan")
    
    # Display everything
    console.print(title_panel)
    console.print("")
    console.print(stats_panel)
    console.print("")
    console.print(thank_you_panel)
    console.print("")
    console.print("[bold yellow]🚀 Exiting LeRobot Bimanual Recording...[/bold yellow]")


@parser.wrap()
def record(cfg: RecordConfig) -> LeRobotDataset:
    init_logging()
    logging.info(pformat(asdict(cfg)))
    if cfg.display_data:
        _init_rerun(session_name="recording")

    robot = make_robot_from_config(cfg.robot)
    logger.debug(msg=f"robot:{robot}")
    teleop = make_teleoperator_from_config(cfg.teleop) if cfg.teleop is not None else None
    logger.debug(msg=f"teleop:{teleop}")
    action_features = hw_to_dataset_features(robot.action_features, "action", cfg.dataset.video)
    logger.debug(msg=f"action_features:{action_features}")
    obs_features = hw_to_dataset_features(robot.observation_features, "observation", cfg.dataset.video)
    logger.debug(msg=f"obs_features:{obs_features}")
    dataset_features = {**action_features, **obs_features}
    logger.debug(msg=f"dataset_features:{dataset_features}")

    if cfg.resume:
        dataset = LeRobotDataset(
            cfg.dataset.repo_id,
            root=cfg.dataset.root,
        )

        if hasattr(robot, "cameras") and len(robot.cameras) > 0:
            dataset.start_image_writer(
                num_processes=cfg.dataset.num_image_writer_processes,
                num_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
            )
        sanity_check_dataset_robot_compatibility(dataset, robot, cfg.dataset.fps, dataset_features)
    else:
        # Create empty dataset or load existing saved episodes
        sanity_check_dataset_name(cfg.dataset.repo_id, cfg.policy)
        dataset = LeRobotDataset.create(
            cfg.dataset.repo_id,
            cfg.dataset.fps,
            root=cfg.dataset.root,
            robot_type=robot.name,
            features=dataset_features,
            use_videos=cfg.dataset.video,
            image_writer_processes=cfg.dataset.num_image_writer_processes,
            image_writer_threads=cfg.dataset.num_image_writer_threads_per_camera * len(robot.cameras),
        )

    # Load pretrained policy
    policy = None if cfg.policy is None else make_policy(cfg.policy, ds_meta=dataset.meta)

    robot.connect()
    if teleop is not None:
        teleop.connect()

    # Use continuous recording mode for indefinite episodes
    listener, events = init_continuous_keyboard_listener()
    
    # Initialize episode counter - if resuming, start from existing episodes
    initial_episodes = dataset.num_episodes if cfg.resume else 0
    
    # Show initial welcome screen
    console = Console()
    console.clear()
    welcome_title = Text("🚀 STARTING XHUMAN BIMANUAL RECORDING", style="bold green")
    welcome_panel = Panel(Align.center(welcome_title), style="bold green")
    console.print(welcome_panel)
    console.print(f"\n[bold cyan]📋 Task:[/bold cyan] [yellow]{cfg.dataset.single_task}[/yellow]")
    console.print(f"[bold cyan]💾 Dataset:[/bold cyan] [yellow]{cfg.dataset.repo_id}[/yellow]")
    console.print(f"[bold cyan]📹 FPS:[/bold cyan] [yellow]{cfg.dataset.fps}[/yellow]")
    
    # Show resume information if applicable
    if cfg.resume and initial_episodes > 0:
        console.print(f"[bold magenta]🔄 Resume Mode:[/bold magenta] [green]Continuing from {initial_episodes} existing episodes[/green]")
    elif cfg.resume:
        console.print(f"[bold magenta]🔄 Resume Mode:[/bold magenta] [yellow]No existing episodes found, starting fresh[/yellow]")
    else:
        console.print(f"[bold magenta]🆕 New Dataset:[/bold magenta] [green]Starting from episode 1[/green]")
    console.print("\n[bold magenta]🎮 Controls:[/bold magenta]")
    console.print("  [green]→[/green] Right Arrow: Finish episode and start next")
    console.print("  [green]←[/green] Left Arrow: Cancel and re-record episode") 
    console.print("  [green]↓[/green] Down Arrow: Continue current episode")
    console.print("  [red]ESC[/red]: Stop recording session")
    console.print("\n[bold yellow]🎬 Ready to start recording! Press any arrow key...[/bold yellow]")
    recorded_episodes = initial_episodes
    # Unlimited episodes if num_episodes is 0, otherwise use the configured limit
    unlimited_mode = cfg.dataset.num_episodes == 0
    
    # Calculate target episodes for limited mode
    target_episodes = cfg.dataset.num_episodes if not unlimited_mode else float('inf')
    
    while unlimited_mode or recorded_episodes < target_episodes:
        log_say(f"Recording episode {recorded_episodes + 1}", cfg.play_sounds)
        
        # Always use infinite time in indefinite mode
        episode_time = float('inf')
        
        record_loop(
            robot=robot,
            events=events,
            fps=cfg.dataset.fps,
            teleop=teleop,
            policy=policy,
            dataset=dataset,
            control_time_s=episode_time,
            single_task=cfg.dataset.single_task,
            display_data=cfg.display_data,
        )

        # Handle episode completion
        if events["rerecord_episode"]:
            log_say("Re-record episode", cfg.play_sounds)
            events["rerecord_episode"] = False
            events["exit_early"] = False
            events["finish_episode"] = False  # Reset finish episode flag
            dataset.clear_episode_buffer()
            continue

        # Save the episode if it wasn't cancelled
        if not events["rerecord_episode"]:
            dataset.save_episode()
            recorded_episodes += 1
            
            # Show beautiful menu after each episode - display total episodes in dataset
            total_episodes_in_dataset = dataset.num_episodes
            show_episode_menu(total_episodes_in_dataset, cfg.dataset.single_task, cfg.dataset.repo_id)
            
            # Reset episode control flags for next episode
            events["finish_episode"] = False
            events["exit_early"] = False
            
            # Wait for user input before proceeding (they need to press arrow keys)
            log_say(f"Episode {recorded_episodes} saved successfully!", cfg.play_sounds)

        if events["stop_recording"]:
            break

    # Show final summary - display total episodes in dataset
    final_total_episodes = dataset.num_episodes
    show_final_summary(final_total_episodes, cfg.dataset.single_task, cfg.dataset.repo_id)
    log_say("Stop recording", cfg.play_sounds, blocking=True)

    robot.disconnect()
    teleop.disconnect()

    if not is_headless() and listener is not None:
        listener.stop()

    if cfg.dataset.push_to_hub:
        dataset.push_to_hub(tags=cfg.dataset.tags, private=cfg.dataset.private)

    log_say("Exiting", cfg.play_sounds)
    return dataset


if __name__ == "__main__":
    record()
